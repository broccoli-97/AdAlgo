# 分析归并排序的时间复杂度，并证明

##  归并排序（Merge sort）
归并排序采用了分而治之的思想，过程可概括为以下几步：
- 将给定的待排序的数组一分为二
- 对两部分数组分别使用归并排序使其有序
- 将有序的两部分数组合并

```c
MergeSort(arr[],l,r)
    if r > l
        middle m = (l+r)/2   //Find the middle point to divide the array into two halves
        mergeSort(arr,l,m)   //Call mergeSort for first half
        mergeSort(arr,m+1,r) //Call mergeSort for second half
        merge(arr,l,m,r)     //Merge the two halves sorted in step 2 and 3
```

<img src=".\fig\mergeSort.png" style="zoom: 67%;" />


## 复杂度证明

根据算法的第一步可知
$$
T(n) =2 T(\frac{n}{2})+ O(n)
$$
- $T(n)$ 表示对$n$个数进行归并排序
- $2 T( n/2 )$表示将 $n$ 个数分成两部分分别进行归并排序 
- $O(n)$ 表示对两个子过程结束之后合并的过程

$$
\begin{aligned}
T(N) &=2 T(N / 2)+ O(N) \\
    &=2\left(2 T(N / 4)+\frac{a}{2} N\right)+O(N) \\
    &=4 T(N / 4)+2 O(N) \\
    &=8 T(N / 8)+3 O(N) \\
    & \vdots \\
    &=2^{k} T\left(N / 2^{k}\right)+k O(N)
    \end{aligned}
$$

当 $N/2^{K}=1$ 时迭代停止，此时 $K=\log_{2}N$

代入，得
$$
T(N) = NT(1)+\log_2N\cdot{}O(N)  = O(N\log{N})
$$


> $O(N) = aN+b$, 来自于把一个待排序序列分解成两个序列的时间，这一操作可以在常数项内完成（设定一个下标的时间）。